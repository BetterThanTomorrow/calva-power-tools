(ns mini.playground)

;; https://github.com/AbhinavOmprakash/snitch
;; To try the Snitch Power Tool out, start by loading the namespace
;; Check the Snitch commands out by searching the command palette for â€œSnitchâ€œ
;; Load the Snitch dependency
;; Instrument a function with snitching by using the command for it with the cursor in a `defn`
;; Evaluate or run something that will call the function
;; Evaluate the local bindings in the function ðŸ¤¯


;; The actual code here is generated by Claude

;; Naive, will not finish this year for anything above 57 (or something)
(defn fibonacci
  "Returns the nth number in the Fibonacci sequence"
  [n]
  (cond
    (<= n 0) 0
    (= n 1) 1
    :else (+ (fibonacci (- n 1))
             (fibonacci (- n 2)))))

(comment
  (count (repeat 10 (fibonacci 40)))
  :rcf)

;; More efficient implementations of the Fibonacci function

(defn fibonacci-memo
  "Returns the nth number in the Fibonacci sequence using memoization"
  [n]
  (let [memo (atom {0 0N, 1 1N})]
    (letfn [(fib [n]
              (if-let [result (get @memo n)]
                result
                (let [result (+ (fib (- n 1)) (fib (- n 2)))]
                  (swap! memo assoc n result)
                  result)))]
      (fib n))))

(defn fibonacci-iterative
  "Returns the nth number in the Fibonacci sequence using an iterative approach"
  [n]
  (cond
    (<= n 0) 0N
    (= n 1) 1N
    :else (loop [a 0N
                 b 1N
                 i 2]
            (if (> i n)
              b
              (recur b (+ a b) (inc i))))))

(defn- fibonacci-linear
  "Returns the nth number in the Fibonacci sequence using linear recursion"
  [n]
  (letfn [(fib-pair [n]
            (if (zero? n)
              [0N 1N]
              (let [[a b] (fib-pair (quot n 2))
                    c (* a (- (* 2N b) a))
                    d (+ (* a a) (* b b))]
                (if (odd? n)
                  [d (+ c d)]
                  [c d]))))]
    (first (fib-pair n))))

(defn say-hello
  "A friendly greeting function"
  [name]
  (str "Hello, " name "! Welcome to interactive Clojure programming."))

(comment
  ;; This is a rich comment block where we can experiment
  ;; Let's try our functions
  (fibonacci 10)
  (say-hello "Clojure fan")

  ;; Let's define a value to work with
  (let [numbers (range 1 11)]

    ;; Now we can play with this data
    (reduce + numbers)
    (map #(* % %) numbers)) ; square each number

  ((fn [s] (str "Hello " s)) "foo")

  ;; Compare performance of different Fibonacci implementations
  (time (fibonacci 30))
  (time (fibonacci-memo 30))
  (time (fibonacci-iterative 30))
  (time (fibonacci-linear 30))

  ;; For larger numbers, only the efficient implementations work well
  (time (fibonacci-memo 100))
  (time (fibonacci-iterative 100))
  (time (fibonacci-linear 100))
  )

;; Let's create a more complex function to demonstrate with
(defn process-collection
  "Processes a collection with a given transformation function"
  [coll transform-fn]
  (map transform-fn coll))
